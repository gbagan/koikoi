import { sum } from './util.civet'

export type Phase = "Init" | "Oya" | "Oya2" | "Oya3" | "NewRound" 
                  | "Discard" | "DiscardPick" | "Draw" | "DrawPick" | "Yakus" | "KoiKoi" 
                  | "ShowKoiKoi" | "RoundOver"

type CardLog = {arr: number[]}[][]

type CardType = 'hand1' | 'hand2' | 'field' | 'draw' | 'pile1' | 'pile2' | 'oya'

export type CardInfo = 
  card: number
  type: CardType
  idx: number

export function cardInfo (card: number, type: CardType, idx: number): CardInfo
  {card, type, idx}


export type RoundState =
  hand: [number[], number[]]
  pile: [number[], number[]]
  fieldSlots: (number | null)[]
  stock: number[]
  oyaCards: number[]
    
  init_board: number[]

  show: number | null
  collect: number[]
    
  turn_16: number
  dealer: 0 | 1
  koikoi: [number[], number[]]

  acceptsKoikoi: boolean

  winner: number | null,
  exhausted: boolean
  turnYakus: [number, number][]
  newYakus: number[]
  turn_point: number
    
  state: Phase
  animation: boolean
  
  wait_action: boolean
  card_log: CardLog


export type GameState =
  round_total: number
  init_points: [number, number]
  init_dealer: 0 | 1 | null
  //player_names: [string, string]
  round_state: RoundState
  round: number
  points: [number, number]
  game_over: boolean
  winner: number | null


//CRANE = {(1,1)}
//    curtain = {(3,1)}
//    moon = {(8,1)}
RAIN_MAN: number := 40
//    phoenix = {(12,1)}
export SAKE: number = 32
    
export LIGHT: number[] := [0, 8, 28, 40, 44] //[[1,1],[3,1],[8,1],[11,1],[12,1]]
export SEED: number[] :=  [4, 12, 16, 20, 24, 29, 32, 36, 41]  // [[2,1],[4,1],[5,1],[6,1],[7,1],[8,2],[9,1],[10,1],[11,2]]
export RIBBON: number[] := [1, 5, 9, 13, 17, 21, 25, 33, 37, 42]
                            //[[1,2],[2,2],[3,2],[4,2],[5,2],[6,2],[7,2],[9,2],[10,2],[11,3]]
export DROSS: number[] := [2, 3, 6, 7, 10, 11, 14, 15, 18, 19, 22, 23, 26, 27, 30, 31,
                           34, 35, 38, 39, 43, 45, 46, 47, SAKE]
              // [[1,3],[1,4],[2,3],[2,4],[3,3],[3,4],[4,3],[4,4],[5,3],[5,4],[6,3],[6,4],[7,3],
              // [7,4],[8,3],[8,4],[9,3],[9,4],[10,3],[10,4],[11,4],[12,2],[12,3],[12,4],[9,1]]
            
BOAR_DEER_BUTTERFLY: number[] := [20,24,36]
FLOWER_SAKE: number[] := [8,SAKE]
MOON_SAKE: number[] := [28,SAKE]
RED_RIBBON: number[] := [1,5,9]
BLUE_RIBBON: number[] := [21,33,37]
RED_BLUE_RIBBON: number[] := RED_RIBBON ++ BLUE_RIBBON

//export cardEq := (c1: Card, c2: Card) => c1[0] === c2[0] && c1[1] === c2[1]

export function sortCards(cards: number[]): number[]
  cards.sort (c1, c2) => c1 - c2
  cards

export cardYakus := (card: number) =>
  mainYaku :=
    if LIGHT.includes card
    then ["light", 3] as [string, number]
    else if SEED.includes card
    then ["seed", 5] as [string, number]
    else if RIBBON.includes card
    then ["ribbon", 5] as [string, number]
    else ["dross", 10] as [string, number]
  output := [mainYaku]
  if BOAR_DEER_BUTTERFLY.includes card then
    output.push ["bdb", 0]
  if FLOWER_SAKE.includes card then
    output.push ["fsake", 0]
  if MOON_SAKE.includes card then
    output.push ["msake", 0]
  if RED_BLUE_RIBBON.includes card then
    output.push ["redblue", 0]
  if RED_RIBBON.includes card then
    output.push ["red", 0]
  if BLUE_RIBBON.includes card then
    output.push ["blue", 0]
  output

export function initRoundState(): RoundState
  state: RoundState :=
    hand: [[], []]
    pile: [[], []]
    stock: []
    init_board: []
    fieldSlots: []
    oyaCards: []
    show: null
    collect: []
    turn_16: 1
    dealer: 0 // todo  dealer !== null ? dealer : (Math.random() * 2 | 0) as any
    koikoi: [[0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0]]
    acceptsKoikoi: false
    winner: null
    exhausted: false
    turn_point: 0
    turnYakus: []
    newYakus: []
    state: "Init"
    wait_action: false
    animation: false
    card_log: []
  //writeCardLog state, 'Init'
  state

export function field(state: RoundState): number[]
  state
    |> .fieldSlots.filter(& !== null)
    |> sortCards

export function initGameState(
  round_num=1,
  round_total=8,
  init_points: [number, number]=[30, 30],
  //player_names: [string, string]=['Player1','Player2']
): GameState
  state: GameState := 
    round_total: round_total
    init_points: [init_points[0], init_points[1]]
    init_dealer: 0       
    //player_names: player_names
    round_state: initRoundState()
    round: round_num
    points: init_points
    game_over: false
    winner: null
  state

export turn8 := (state: RoundState) =>
  (state.turn_16+1) / 2 | 0

export function turnPlayer(state: RoundState): 0 | 1
  if (state.turn_16+state.dealer)%2==1 then 0 else 1

export sameMonth := (c1: number, c2: number) =>
  (c1 / 4 | 0) === (c2 / 4 | 0)

export function pairingCards(state: RoundState, card: number): number[]
  field(state).filter (c) => sameMonth(c, card)

export cardInter := (xs: number[], ys: number[]) =>
  xs.filter (c) => ys.includes(c)
  /*
  output := []
  for c1 of xs
    for c2 of ys
      if c1 === c2
        output.push c1
  output
  */


cardInterLen := (xs: number[], ys: number[]) =>
  total .= 0
  for c1 of xs
    for c2 of ys
      if c1 === c2
        total++
  total

cardSubset := (xs: number[], ys: number[]) =>
  xs.every (c) => ys.includes(c)

koikoiNum := (state: RoundState, player: 0 | 1) =>
  state.koikoi[player] |> sum

export function yaku(state: RoundState, player: 0 | 1): [number, number][]
  total: [number, number][] := []
  pile := state.pile[player]
  koikoi := koikoiNum(state, player)
        
  numLights := cardInterLen(pile, LIGHT)
  ownsRainMan := pile.includes(RAIN_MAN)
  if numLights == 5
    total.push [0, 10]         
  else if numLights == 4 && !ownsRainMan
    total.push [1, 8]        
  else if numLights == 4
    total.push [2, 7]    
  else if numLights == 3 && !ownsRainMan
    total.push [3, 5]
        
  numSeeds := cardInterLen(pile, SEED)
  
  if cardSubset(BOAR_DEER_BUTTERFLY, pile) // todo
    total.push [4, 5]
  if cardSubset(FLOWER_SAKE, pile)
    if koikoi === 0
      total.push [5, 1]            
    else
      total.push [6, 3]
  if cardSubset(MOON_SAKE, pile)
    if koikoi === 0
      total.push [7, 1]
    else
      total.push [8, 3]
  if numSeeds >= 5
    total.push [9, numSeeds-4]
            
  numRibbons := cardInterLen(pile, RIBBON)
  contains_red := cardSubset(RED_RIBBON, pile)
  contains_blue := cardSubset(BLUE_RIBBON, pile)
  if contains_red && contains_blue
    total.push [10, 10]
  if contains_red
    total.push [11, 5]
  if contains_blue
    total.push [12, 5]
  if numRibbons >= 5
    total.push [13, numRibbons-4]
            
  numDross := cardInterLen(pile, DROSS)
  if numDross >= 10
    total.push [14, numDross-9]
            
  if koikoi > 0
    total.push [15, koikoi]
        
  total

export YAKU_TEXT: string[] := [
  "Gokō (五光)"  // 0
  "Shikō (四光)" // 1
  "Ame-Shikō (雨四光)" // 2
  "Sankō (三光)" // 3
  "Inoshikachō (猪鹿蝶)" // 4
  "Hanami-zake (花見酒)" // 5 
  "Hanami-zake (花見酒)" // 6
  "Tsukimi-zake (月見酒)" // 7
  "Tsukimi-zake (月見酒)" // 8
  "Tane (タネ)" // 9
  "Akatan, Aotan no Chōfuku (赤短・青短の重複)" // 10
  "Akatan (赤タン)" // 11
  "Aotan (青タン)" // 12
  "Tan (タン)" // 13
  "Kasu (カス)" // 14
]

export YAKU_CARDS: number[][] := [
  LIGHT  // 0
  LIGHT // 1
  LIGHT // 2
  LIGHT // 3
  BOAR_DEER_BUTTERFLY, // 4
  FLOWER_SAKE // 5 
  FLOWER_SAKE // 6
  MOON_SAKE // 7
  MOON_SAKE // 8
  SEED // 9
  RED_BLUE_RIBBON // 10
  RED_RIBBON // 11
  BLUE_RIBBON // 12
  RIBBON // 13
  DROSS // 14
]

export yakuPoints := (state: RoundState, player: 0 | 1) =>
  points := yaku(state, player)
    |> .filter(&[0] !== 15)
    |> .map(&[1])
    |> sum

  koikoi := koikoiNum(state, player)
  if koikoi <= 3
    points + koikoi
  else
    points * (koikoi - 2)  
